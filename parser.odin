package ini

import "core:strings"
import "core:fmt"

// The parser reads the list of tokens generated by the lexer and converts them into an ini.Config
Parser :: struct {
    pos: int,
    tokens: [dynamic]Token,
    config: ^Config,
    section: ^Config,
}

// Creates a new parser with the given token list and config then returns a pointer to it.
new_parser :: proc(tokens: [dynamic]Token, config: ^Config) -> ^Parser {
    p := new(Parser)
    p.pos = 0
    p.tokens = tokens
    p.config = config
    p.section = nil
    return p
}

// Parses the tokens into a config struct
parse :: proc(p: ^Parser) {
    t: Token

    for p.pos < len(p.tokens) {
        t = p.tokens[p.pos]

        #partial switch t.type {
        case .SECTION_LEFT: parse_section(p)
        case .IDENTIFIER: parse_key(p)
        case .COMMENT: p.pos += 1 // TODO Add comments to config?
        case .EOL: p.pos += 1
        case .EOF: return
        case:
            fmt.println("Unexpected token: ", t)
            p.pos += 1 // TODO Errors
        }
    }
}

// Parses a "key = value" statement.
parse_key :: proc(p: ^Parser) {
    key := strings.clone(p.tokens[p.pos].value)
    p.pos += 1

    if p.tokens[p.pos].type != .DELIMITER {
        fmt.println("Expected delimiter after key")
        return
    }

    p.pos += 1
    value := strings.clone(p.tokens[p.pos].value)
    p.pos += 1

    if p.section == nil {
        set(p.config, key, value)
    } else {
        set(p.section, key, value)
    }
}

// Parses a [section] statement
parse_section :: proc(p: ^Parser) {
    p.pos += 1
    section_name := strings.clone(p.tokens[p.pos].value)
    p.pos += 1

    if p.tokens[p.pos].type != .SECTION_RIGHT {
        fmt.println("Expected closing bracket")
        return
    }

    p.pos += 1
    if p.tokens[p.pos].type != .EOL {
        fmt.println("Expected newline after section")
        return
    }

    p.pos += 1
    p.section = add_section(p.config, section_name)
}